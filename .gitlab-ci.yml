stages:
  - validate
  - auth
  - build
  - test

.aws_auth: &aws_auth
  - echo "role - ${MASTER_IODC_ROLE_ARN}"
  - >
    export $(printf "AWS_ACCESS_KEY_ID=%s AWS_SECRET_ACCESS_KEY=%s AWS_SESSION_TOKEN=%s"
    $(aws sts assume-role-with-web-identity
    --role-arn ${MASTER_IODC_ROLE_ARN}
    --role-session-name "GitLabRunner-${CI_PROJECT_ID}-${CI_PIPELINE_ID}"
    --web-identity-token ${ID_TOKEN_1}
    --duration-seconds 3600
    --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]'
    --output text))
  - aws sts get-caller-identity
  - aws s3 ls

  - echo -e "Assume role from development account"
  - set -- $(aws sts assume-role
    --role-arn ${DEVELOP_IODC_ROLE_ARN}
    --role-session-name terraform-execution-full-access
    --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]'
    --output text)

  - export AWS_ACCESS_KEY_ID="$1"
  - export AWS_SECRET_ACCESS_KEY="$2"
  - export AWS_SESSION_TOKEN="$3"
  - export AWS_DEFAULT_REGION="us-east-1"
  - aws s3 ls

checkov:
  # https://www.checkov.io/4.Integrations/GitLab%20CI.html
  stage: test
  allow_failure: true  # True for AutoDevOps compatibility
  image:
    name: bridgecrew/checkov:latest
    entrypoint:
      - '/usr/bin/env'
      - 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  rules:
    - if: $SAST_DISABLED
      when: never
    - if: $CI_COMMIT_BRANCH
      exists:
        - '**/*.yml'
        - '**/*.yaml'
        - '**/*.json'
        - '**/*.template'
        - '**/*.tf'
        - '**/serverless.yml'
        - '**/serverless.yaml'
  script:
    - checkov -d . -o junitxml | tee checkov.test.xml
  artifacts:
    reports:
      junit: "checkov.test.xml"
    paths:
      - "checkov.test.xml"

aws_auth:
  stage: auth
  image:
    name: yuriyf/tf-aws-k8s:1.0.0
    entrypoint: [""]
  id_tokens:
    ID_TOKEN_1:
      aud: https://gitlab.com
  script:
    - *aws_auth
  #rules:
  #  - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "schedule"

# build:
#   stage: build
#   image:
#     name: docker:20
#     entrypoint: [""]
#   tags:
#     - build
#   script:
#     - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
#     - docker build -t ${CI_REGISTRY_IMAGE} .
#     - docker push $CI_REGISTRY_IMAGE:latest

#     - docker tag $CI_REGISTRY_IMAGE $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
#     - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
